\documentclass[document]{xmgr}
% Jeśli nowe rozdziały mają się zaczynać na stronach
% nieparzystych:
%\documentclass[openright]{xmgr}

%\defaultfontfeatures{Scale=MatchLowercase}
%\setmainfont[Numbers=OldStyle,Ligatures=TeX]{Minion Pro}
%\setsansfont[Numbers=OldStyle,Ligatures=TeX]{Myriad Pro}
% for fontspec version < 2.0
\setmainfont[Numbers=OldStyle,Mapping=tex-text]{Arial}
\setsansfont[Numbers=OldStyle,Mapping=tex-text]{Times New Roman}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings} 

\setmonofont[Scale=0.75]{Monaco}

% Opcjonalnie identyfikator dokumentu
% drukowany tylko z włączoną opcją 'brudnopis':
\wersja   {wersja wstępna [\ymdtoday]}

\author   {Szymon Rękawek}
\nralbumu {206288}
\email    {rekawekszymon@gmail.com}

\title    {Gra Thuego}
\date     {01.01.2016}
\miejsce  {Gdańsk}

\opiekun  {prof. dr hab. T. Dzido}

% dodatkowe polecenia
%\renewcommand{\filename}[1]{\texttt{#1}}
\definecolor{stress}{cmyk}{0,1,0.13,0} % RubineRed
\definecolor{topic}{cmyk}{0.98,0.13,0,0.43} % MidnightBlue

\begin{document}

% streszczenie
\begin{abstract}

\end{abstract}

% słowa kluczowe
\keywords{Thue}

% tytuł i spis treści
\maketitle

% wstęp
\introduction

Tematem niniejszej pracy jest Gra Thuego. Axel Thue był norweskim matematykiem żyjącym w latach 1863 - 1922, znanym z prac z zakresu kombinatoryki.

Thue pracował nad problemami, powstałymi w wyniku badań nad sekwencjami symboli. Praca Thue [1] opisywała problem, który autor nazwał \textit{nieredukowalne słowa} (\textit{irreducible words}). Poświęca w niej szczególną uwagę dwu i trzy literowym przypadkom. W skrócie wprowadza pojęcie znane obecnie jako \textit{Thue-Morse word} i pokazuje, że nieskończone słowa bez nasunięć (\textit{Overlap-free}) są pochodnymi tej sekwencji. W swoich pracach definiuje kolejną strukturę, a mianowicie infinite \textit{Square-Free word}, oraz przedstawia sposoby generowania nieskończenie długich słów wolnych zarówno od kwadratów jak i nasunięć.

Gra która powstała na podstawie teorii Thuego w skrócie polegała będzie na utworzeniu jak najdłuższego ciągu znaków nad określonym z góry alfabetem. Zależnie od trybu gry, kończyć się ona będzie w momencie gdy pojawi się zdefiniowany na początku rodzaj powtórzenia w tworzonym przez nas, bądź algorytm ciągu. Jednym z trybów gry jest walka komputera przeciwko niemu samemu, po takiej rozgrywce przedstawione zostaną złożoności czasowe oraz wnioski wynikające z obranej przez oponentów taktyki. 

Ostatnia część pracy poświęcona jest analizie algorytmów zarówno pod względem czasu ich wykonywania jak i zdolności do przewidywania ruchów przeciwnika.

\chapter{Teorie Axela Thue na temat sekwencji symboli}
lbaldsaldsal dsadsa asdkdsak sadkdsa dsadsadsak dsak 
dsa dsajdsajdas 
\section{Definicje}
\begin{itemize}
\item Alfabet jest skończonym zbiorem symboli lub liter.
\item Słowo alfabetu $A$ jest skończoną sekwencją elementów z $A$. 
\item Długość słowa $\omega$ jest reprezentowana przez $|\omega|$.
\item Puste słowo o długości $0$ jest reprezentowane przez $\varepsilon$.
\item Czynnik (factor) słowa $\omega$ jest słowem $u$, które występuje wewnątrz $\omega$ formie $\omega = xuy$, podczas gdy $x$ oraz $y$ również są słowami tego alfabetu.
\item Kwadrat (square) jest niepustym słowem w formie $uu$, gdzie $u$ jest niepuste.
\item Square-free, słowo jest wolne od kwadratów, jeśli żaden z jego czynników nie jest kwadratem.
\item Nasunięcie (Overlap) jest słowem w formie $xuxux$, gdzie $x$ jest niepuste. Nazwa pojęcia wzięła się z tego, że $xux$ występuje dwa razy w $xuxux$. Pierwszy raz jako prefiks (początkowy czynnik) oraz jako sufiks (końcowy czynnik) i te dwa wystąpienia mają wspólną część - centralne $x$, a więc \textit{nasuwają} się na siebie.
\item Overlap-free - słowo w którym żaden z czynników nie nasuwa się na siebie.
W definicji Axela Thue słowo $\omega$ w alfabecie długości n jest nieredukowalne jeśli jakiekolwiek dwa wystąpienia tego samego słowa jako czynnik wewnątrz $\omega$ są zawsze oddzielone od siebie przez $n-2$ liter. Oznacza to, że nieredukowalne dwuliterowe słowo jest bez nasunięć i nieredukowalne trzyliterowe słowo jest bez kwadratów.
\item Morfizm - mapowanie obiektu z jednej matematycznej struktury w inną.
\end{itemize}



\section{Thue-Morse word}
Rozważmy nieskończone słowo

{\centering $01101001100101101001011001101001 ...$ \par}

Zostało ono nazwane po Thue, który badał jego właściwości w referacie z 1906 roku, oraz Morsie, który odkrył je na nowo w latach 20 XIX wieku. Słowo Thue-Morse'a występuje również o wiele wcześniej w wiadomościach Prouheta[200] z Francuską Akademią Nauk w 1851 roku. Rzeczywiście Prouhet podał więcej ogólnych konstrukcji, uzyskując nie tylko słowo Thue-Morse'a, ale całą rodzinę słów na większych alfabetach mających inne interesujące właściwości. Słowa te czasami odnoszą się do ogólnych słow Thue-Morse'a lub słów Prouheta.

Niech $A = \{a, b\}$ będzie dwuliterowym alfabetem. Rozważmy morfizm $\mu$ z monoidu $A*$, który definiuje się następująco:



\begin{tabbing}

\hspace{8em}\= $\mu(a) = ab$,\hspace{7em}\= $\mu(b) = ba$\\
Dla $n \geq 0$:\\
\> $u_n = \mu^n(a)$,\> $v_n = \mu^n(b)$\\
Wtedy:\\
\> $u_0 = a$ \> $v_0 = b$\\
\> $u_1 = ab$ \> $v_1 = ba$\\
\> $u_2 = abba$	 \> $v_2 = baab$\\
\> $u_3 = abbabaab$ \> $v_3 = baababba$\\
Wzór ogólny:\\
\> $u_{n+1} = u_n v_n,$ \> $v_{n+1} = v_n u_n$\\
oraz:\\
\> $u_n = \overline{v}_n,$ \> $v_n = \overline{u}_n$
\end{tabbing}

gdzie $\overline{\omega}$ jest uzyskiwane z $\omega$ przez zamianę $a$ oraz $b$. Słowa $u_n$ i $v_n$ są często nazywane \textit{Blokami morsa}. Można łatwo zauważyc że $u_{2n}$ oraz $v_{2n}$ są palindromami oraz to że $u_{2n+1} = \neg v_{2n+1}$, gdzie $\neg w$ jest negacją $w$. Morfizm $\mu$ może być rozszerzony do nieskończonych słow, które mają dwa stałe punkty:


{\centering 
$t = abbabaabbaababbabaab... = \mu(t)$ \\
$~t = baababbaabbabaababba... = \mu(~t)$ 
\par}



Przedstawione powyżej słowo $t$ jest sekwencją Thue-Morse'a. Jest wiele innych sposobów na stworzenie tego słowa. Niech $t_n$ będzie n-tym symbolem w $t$, zaczynając od $n = 0$. Wtedy można pokazać, że:

\[
t_n=
\left \{
\begin{tabular}{ccc}
$a\ if\ d_1(n) \equiv (mod\ 2)$ \\
$a\ if\ d_1(n) \equiv (mod\ 2)$
\end{tabular}
\right \}
\]

\begin{align*}
  &\phantom{{}\leq{}} \text{gdzie } d_1(n) \text{ jest liczbą bitów równych 1 w binarnej reprezentacji } n \text{.}  \\
  & \text{Dla } n \leq 12 \text{ oraz } n \in \mathbb{N} \text{ generowane jest następujące słowo:}  \\
\end{align*}

\begin{tabbing}
$bin(0)$\hspace{1em} \= $= 0,$\hspace{7em} \= $d_1 (0)$\hspace{1em} \= $= 0\ mod\ 2 = 0 \to a$ \\
$bin(1)$ \> $= 1,$ \> $d_1 (1)$ \> $= 1\ mod\ 2 = 1 \to b$\\
$bin(2)$ \> $= 10,$ \> $d_1 (2)$ \> $= 1\ mod\ 2 = 1 \to b$\\
$bin(3)$ \> $= 11,$ \> $d_1 (3)$ \> $= 2\ mod\ 2 = 0 \to a$\\
$bin(4)$ \> $= 100,$ \> $d_1 (4)$ \> $= 1\ mod\ 2 = 1 \to b$\\
$bin(5)$ \> $= 101,$ \> $d_1 (5)$ \> $= 2\ mod\ 2 = 0 \to a$\\
$bin(6)$ \> $= 110,$ \> $d_1 (6)$ \> $= 2\ mod\ 2 = 0 \to a$\\
$bin(7)$ \> $= 111,$ \> $d_1 (7)$ \> $= 3\ mod\ 2 = 1 \to b$\\
$bin(8)$ \> $= 1000,$ \> $d_1 (8)$ \> $= 1\ mod\ 2 = 1 \to b$\\
$bin(9)$ \> $= 1001,$ \> $d_1 (9)$ \> $= 2\ mod\ 2 = 0 \to a$\\
$bin(10)$ \> $= 1010,$	\> $d_1 (10)$ \> $= 2\ mod\ 2 = 0 \to a$\\
$bin(11)$ \> $= 1011,$ 	\> $d_1 (11)$ \> $= 3\ mod\ 2 = 1 \to b$\\
$bin(12)$ \> $= 1100,$ 	\> $d_1 (12)$ \> $= 2\ mod\ 2 = 0 \to a$
\end{tabbing}

{\centering $t = abbabaabbaaba$ \par}

W konsekwencji istnieje skończony automat obliczający wartości $t_n$. Automat ten ma dwa stany końcowe $0$ oraz $1$. Na początku czyta łańcuch znaków $bin(n)$ od lewej do prawej, zaczynając od $n = 0$. Ostateczny stan równy jest $0$ lub $1$ i definiuje czy $t_n$ jest równe $a$ lub $b$. W skrócie obliczenie jakie wykonuje automat to $d_1(n)\ modulo\ 2$.


\section{Square-free word}
Łatwo można zauważyc, że jedynymi słowami bez kwadratów w alfabecie $A = \{a, b\}$ są: $a, b, ab, ba, aba, bab$. Istnieje jednak dowolnie długi ciąg znaków wolny od kwadratów dla słów nad alfabetem trzyliterowym. By stworzyć dowolne słowo wolne od kwadratów Thue wymyślił następujący algorytm.\\
Mając alfabet $A = \{a, b, c\}$ należy zastąpić każde wystąpienie litery $a$ przez $abac$,  $b$ przez $babc$ oraz $c$ przez $bcac$, jeśli jest poprzedzone przez $a$ lub $acbc$, jeśli jest poprzedzone przez $b$. Zaczynając od litery $a$ otrzymujemy nieskończone słowo które nie zawiera kwadratów.

{\centering $abacbabcabacbcacbabcabacbabcacbcabacbabc...$ \par}

W 1912 roku Axel Thue wymyślił inny sposób na generowanie nieskończonego słowa bez kwadratów na trzech literach z użyciem następującego morfizmu. 
\begin{itemize}
\item $a \to abcab$
\item $b \to acabcb$
\item $c \to acbcacb$
\end{itemize}


Po raz kolejny zastępujemy każde wystąpienie z naszych liter przez zdefiniowane sekwencje. Jest to dość skomplikowana struktura, zsumowana długość łańcuchów wynosi 18. A Carpi [7] dowiódł, że morfizm na alfabecie składającym się z trzech liter tworzący słowa wolne od kwadratów musi mieć długość równą co najmniej $18$.

% - Bob wybiera indeks w ciągu, natomiast Alicja wybiera symbol z wcześniej ustalonego zbioru $A$.
\section{Thue online}
Praca J. Grytczuka, P. Szafrugi i M. Zmarza pod tytułem Online version of theorem of Thue[8] opisuje wersję online teorii Thuego. Jest to gra dla dwóch graczy Boba oraz Alicji. Podczas rozgrywki Alicja i Bob naprzemiennie wykonując swoje ruchy tworzą ciąg bez kwadratów. Celem Boba jest jak najszybsze skończenie rozgrywki poprzez utworzenie kwadratu, Alicja natomiast musi tego unikać.

Wartym wspomnienia jest uproszczony tryb gry, podczas którego mamy dwóch graczy - Alicję i Boba, tak jak zostało wspomniane tylko Alicji zależy na tym by uniknąć kwadratów. Rozgrywka polega na tym, że Alicja i Bob wybierają na przemian symbole z ustalonego zbioru $A$, oraz dopisują je na końcu istniejącego ciągu. W momencie, gdy pojawia się kwadrat $aa$, jego druga część, czyli w naszym przypadku prawe $a$, zostaje usunięte. Zostało udowodnione w [9] J. Grytczuk, J. Kozik, P. Micek, New approach to nonrepetitive sequences. Random Structures Algorithms, DOI 10.1002/rsa.20411. , że Alicja jest wstanie stworzyć dowolnie długi ciąg bez kwadratów, nie zważając na ruchy Boba. Powyższe jednak jest możliwe pod warunkiem, że moc zbioru $A$ wynosi conajmniej $8$.

Innym typem gry przedstawionym w pracy[8] jest Online Thue game. Po raz  
kolejny gracze wykonują swoje ruchy na przemian. W swojej rundzie Bob wybiera indeks w istniejącym ciągu $S$, który jest sprecyzowany przez 
liczbę $i \in \{0, 1, ..., n\}$, następnie Alicja wybiera symbol $x \in A
$, który jest wstawiany jedną pozycję w prawo od $s_i$, dając nam nową sekwencję $S' = s_1, ..., s_i, x, s_{i+1}, ...,s_n$ w momencie gdy $i = 0$, $x$ jest ustawiany na początku $S$. Celem Boba jest zmuszenie Alicji do stworzenia kwadratu, podczas gdy Alicja unika tego najdłużej jak to możliwe. Na przykład, jeśli ustalimy, że $A = \{a, b, c\}$ i $S = acbc$, wtedy Bob wybierając indeks $i = 1$ nie daje Alicji możliwości wybrania symbolu, który nie stworzyłby kwadratu. Rzeczywiście wybierając jakikolwiek $x \in A$ doprowadza do utworzenia kwadratu w $S'$: $\textbf{aa}cb, a\textbf{bcbc}, a\textbf{cc}bc$. W przypadku gdy Bob obierze dobrą strategię, rozgrywka na 3 symbolach skończy się na ciągu długości 5, nie ważne jak dobrą strategię obierze Alicja. Oczywiście im większą moc ma zbiór $A$, tym więcej ruchów, będzie potrzebował Bob, by zakończyć rozgrywkę. 

[9] A. Ku ̈ndgen and M. J. Pelsmajer, Nonrepetitive colorings of graphs of bounded treewidth, Discrete Math. 308 (2008), 4473–4478. [10] J. Bara ́t, P. P. Varju ́. On square-free vertex colorings of graphs. Studia Sci. Math. Hungar. 44 (2007) 411–422. 

Grytczuk, Szafruga i Zmarza[8] wysnuli teorię, że istnieje strategia dla Alicji gwarantująca jej utworzenie dowolnie długiej gry w online Thue game na zbiorze o mocy 12 symboli. Teorię swoją oparli o prace Ku ̈ndegena i Pelsmajera[9], oraz Baráta and Varju[10], na temat niepowtarzalnych kolorowań grafów planarnych (outerplanar graphs?).

Autorzy [8] nie zamkneli do końca problemu i zauważyli, że może istnieć strategia dla Alicji, która pozwoliłaby jej na dowolnie długą rozgrywkę nawet przy mocy zbioru $A$ równej 9.


\section{Komputerowa implementacja Online Thue Game}

Komputerowa implementacja gry Thuego opiera się na pomyśle gry z pracy [8]. W grze dostępnych jest kilka trybów zarówno dla jednego oraz dwóch graczy jak i komputerowa symulacja, czyli gra komputera przeciwko niemu samemu.

Implementacja gry Online Thue Game nazywana będzie \textbf{Longest Square-Free word}.
Zasady pozostają niemal identyczne. Na początku gry gracze ustalają moc zbioru symboli, oraz otrzymują swoje role, jeden z nich staje się architektem, drugi malarzem. Rola architekta polega na wybieraniu odpowiedniego indeksu w ciągu tworzonym przez graczy, pod którym powstanie nowy element. Malarz natomiast określa kolor wstawianego elementu. Gra kończy się w momencie, gdy w ciągu tworzonym przez graczy pojawia się \textbf{kwadrat}. Indeks $i$  podawany przez architekta nie może być mniejszy od zera oraz większy niż $n$, gdzie $n$ jest równe liczbie elementów w ciągu. Na początku gry ciąg $S$ zawiera tylko jeden symbol równy 0.
Grę rozpoczyna architekt, gracze wykonują swoje ruchy na przemian. Malarz otrzymuje punkt za każdy pomalowany element, który nie tworzy \textbf{kwadratu} wewnątrz ciągu.
By wyłonić zwycięzcę potrzebne są dwie rundy. Każdy z graczy musi sprawdzić się zarówno jako malarz i architekt. Wygrywa osoba, która zdobyła więcej punktów jako malarz.

Tryb ten dostępny jest również dla jednego gracza, rolę przeciwnika otrzymuje wtedy komputer, który działa według algorytmu przewidującego określoną przez poziom trudności liczbę ruchów do przodu. Algorytm może pełnić zarówno rolę budowniczego jak i malarza.

Bliźniaczym trybem gry, opierającym się na tych samych zasadach z niewielką różnicą jest \textbf{Longest Overlap-Free word}. 
Różnica polega na tym, że malarz w tworzonym ciągu musi unikać \textbf{nasunięcia}.

Podobnie jak w \textbf{Longest Square-Free word} jest możliwość gry przeciwko algorytmowi, który jest w stanie przewidywać określoną ilość ruchów do przodu.

\chapter{Algorytmy obsługujące grę}
\section{Algorytm wyszukiwania powtórzeń kwadratowych}

\lstset{language=Java}

\begin{lstlisting}[frame=single]
	private List<Integer> findSquare() {
		List<Integer> squareSeq = null;
		int maxSeqSize = sequence.size()/2;
		int minSeqSize = 1;
		for(int subSeqSize=minSeqSize; 
			subSeqSize<=maxSeqSize; 
			subSeqSize++) {
			squareSeq = compareSubSeq(subSeqSize);
			if(squareSeq != null) {
				return squareSeq;
			}
		}
		return null;
	}
\end{lstlisting}

\chapter{Narzędzia i~standardy pokrewne}

Systemy SGML, ze względu na mnogość funkcji jakie spełniają i~ich
kompleksowe podejście do oznakowywania i~przetwarzania dokumentów
tekstowych, są bardzo skomplikowane. Możemy wyróżnić dwa podejścia do
budowy takich systemów.  Z~jednej strony, buduje się systemy
zindywidualizowane, oparte o~specyficzne narzędzia tworzone w~takich
językach, jak: C, C++, Perl czy Python. Edytory strukturalne, filtry
do transformacji formatów czy parsery\index{parser} i~biblioteki
przydatne do konstrukcji dalszych narzędzi, tworzone są według potrzeb
określonych, pojedynczych systemów.

Z~drugiej strony, twórcy oprogramowania postanowili pójść krok dalej
i~połączyć te różne narzędzia w~jedną całość. Tą całość miał stanowić
DSSSL lub jego XML-owy odpowiednik -- standard XSL. Ze względu na
oferowane możliwości można twierdzić, że tworzenie i~używanie narzędzi
implementujących standard DSSSL/XSL, jest najwłaściwszym
podejściem. Przemawiają za tym różne argumenty, ale najważniejszym
z~nich jest to, że mamy tu możliwość stworzenia niezależnego od
platformy programowej i~narzędziowej zbioru szablonów -- przepisów jak
przetwarzać dokumenty SGML.

\section{Przetwarzanie dokumentów SGML -- standard DSSSL\label{s:dsssl}}

DSSSL (\textit{Document Style Semantics and Specification Language\/})
-- to międzynarodowy standard ściśle związany ze standardem SGML.
Standard ten, można podzielić na następujące części:

\begin{itemize}
\item język transformacji (\textit{transformation language\/}).  To
  definicja języka służącego do transformacji dokumentu oznaczonego
  znacznikami zgodnie z~pewnym DTD na dokument oznaczony zgodnie
  z~innym~DTD.
\item język stylu (\textit{style language\/}) opisujący sposób
  formatowania dokumentów SGML.
\item język zapytań (\textit{query language\/}) służy do
  identyfikowania poszczególnych fragmentów dokumentu SGML.
\end{itemize}

Opisane główne części składowe standardu DSSSL dają obraz tego, jak
wiele aspektów przetwarzania zostało zdefiniowanych i~jak
skomplikowany jest to problem. Jest to głównym powodem tego, że mimo
upływu kilku lat od zdefiniowania standardu nie powstały ani
komercyjne ani wolnodostępne aplikacje wspierające go
w~całości. Istnieją natomiast \emph{nieliczne\/} narzędzia realizujące
DSSSL w~ograniczonym zakresie, głównie w~części definiującej język
stylu, który odpowiada za opatrzenie dokumentu czysto strukturalnego
w~informacje formatujące. Daje to możliwość publikacji dokumentów SGML
zarówno w~postaci elektronicznej, hipertekstowej czy też drukowanej.

\section{Przetwarzanie dokumentów XML -- standard XSL\label{s:xsl}}

Tak jak XML jest \emph{uproszczoną\/} wersją standardu SGML, tak XSL
jest uproszczonym odpowiednikiem standardu DSSSL. W~szczególności,
wyróżnić można w~tym standardzie następujące części składowe:

\begin{itemize}
\item język transformacji (XSLT) To definicja języka służącego do
  transformacji dokumentu.
\item język zapytań (XPath) służy do identyfikowania poszczególnych
  fragmentów dokumentu.
\item język stylu deefiniujący sposób formatowania dokumentów XML.
\end{itemize}

\chapter{Przegląd dostępnych narzędzi\label{PRZEGLAD.NARZEDZI}}

W~celu wykorzystania standardu SGML do przetwarzania dokumentów,
niezbędne jest zebranie odpowiedniego zestawu narzędzi. Narzędzi do
przetwarzania dokumentów SGML jest wiele. Są to zarówno całe
systemy zintegrowane, jak i~poszczególne programy, biblioteki czy
skrypty wspomagające.

\section{Narzędzia do przeglądania dokumentów SGML}

Do tej kategorii oprogramowania zaliczamy przeglądarki dokumentów
SGML oraz serwery sieciowe wspomagające standard SGML, przy
czym rozwiązań wspierających standard XML jest już w~chwili obecnej
dużo więcej i~są dużo powszechniejsze.

Jeżeli chodzi o~przeglądarki to zarówno Internet Explorer jak
i~Netscape umożliwiają bezpośrednie wyświetlenie dokumentów XML;
ponieważ jednak nie wspierają w~całości standardu XML, prowadzi to
ciągle do wielu problemów\footnote{Z~innych mniej popularnych
  rozwiązań można wymienić takie aplikacje, jak: HyBrick SGML
  Browser firmy Fujitsu Limited, Panorama Publisher firmy InterLeaf
  Inc, DynaText firmy Inso Corporation czy darmowy QWeb. W~przypadku
  serwerów zwykle dokonują one transformacji ,,w~locie'' żądanych
  dokumentów na format HTML (rzadziej bezpośrednio wyświetlają
  dokumenty XML).  Ta kategoria oprogramowania ma, z~punktu widzenia
  projektu, znaczenie drugorzędne.}.

\section{Parsery SGML}
Program \texttt{nsgmls} (z~pakietu \texttt{SP} Jamesa Clarka) jest
doskonałym parserem\index{parser} dokumentów SGML, dostępnym
publicznie.  Parser \texttt{nsgmls} jest dostępny w~postaci źródłowej
oraz w~postaci programów wykonywalnych przygotowanych na platformę
MS~Windows, Linux/Unix i~inne. Oprócz analizy poprawności dokumentu
parser\index{parser} ten umożliwia również konwersję danych do formatu
ESIS\index{ESIS}, który wykorzystywany jest jako dane wejściowe przez
wiele narzędzi do przetwarzania i~formatowania dokumentów SGML.
Dodatkowymi, bardzo przydatnymi elementami pakietu \texttt{SP} są:
program \texttt{sgmlnorm} do normalizacji, program \texttt{sx} służący
do konwersji dokumentu SGML na XML oraz biblioteki programistyczne,
przydatne przy tworzeniu specjalistycznych aplikacji służących do
przetwarzania dokumentów SGML.

W~przypadku dokumentów XML publicznie dostępnych, parserów jest
w~chwili obecnej kilkadziesiąt. Do popularniejszych zaliczyć można
Microsoft Java XML Parser firmy Microsoft, LT XML firmy Language
Technology Group, Exapt oraz XP (James Clark)

\section{Wykorzystanie języków skryptowych}

\section{Wykorzystanie szablonów XSL}

Stosując wersję XML typu DocBook można wykorzystać szablony stylów
przygotowane w~standardzie XSL (autor N.~Walsh). W~chwili obecnej
są dostępne narzędzia umożliwiające przetworzenie dokumentów XML do
postaci drukowanej (Adobe PDF) oraz hipertekstowej (HTML).

Podobnie jak w~przypadku szablonów DSSSL, szablony stylów XSL są
sparametryzowane i~udokumentowane i~dzięki temu łatwe w~adaptacji. Do
zamiany dokumentu XML na postać prezentacyjną można wykorzystać jeden
z~dostępnych publicznie procesorów XSLT
(por.~tabela~\ref{zest:proces:xslt}).

\begin{table}[!htb]
\begin{tabular}{|l|l|l|} \hline
Nazwa & Autor      & Adres URL \\ \hline
\texttt{sablotron} & Ginger Alliance & \url{http://www.gingerall.com} \\ \hline
\texttt{Xt}        & J.~Clark & \url{http://www.jclark.com} \\ \hline
\texttt{4XSLT}     & FourThought & \url{http://www.fourthought.com} \\ \hline
\texttt{Saxon}     & Michael Kay &  \url{http://users.iclway.co.uk/mhkay/saxon} \\ \hline
\texttt{Xalan}     & Apache XML Project & \url{http://xml.apache.org} \\ \hline
\end{tabular}
\caption{Publicznie dostępne procesory XLST\label{zest:proces:xslt}}
\source{Opracowanie własne}
\end{table}

XSL:FO jest skomplikowanym językiem o~dużych możliwościach,
zawierającym ponad 50 różnych ,,obiektów formatujących'', począwszy od
najprostszych, takich jak prostokątne bloki tekstu poprzez wyliczenia,
tabele i~odsyłacze. Obiekty te można formatować wykorzystując przeszło
200 różnych właściwości (\emph{properties\/}), takich jak: kroje,
odmiany i~wielkości pisma, odstępy, kolory itp.
W~tym dokumencie przedstawione jest absolutne miniumum informacji
na temat standardu XSL:FO.

Cały dokument XSL:FO zawarty jest wewnątrz elementu \texttt{fo:root}.
Element ten zawiera (w~podanej niżej kolejności):

\begin{itemize}
\item dokładnie jeden element \texttt{fo:layout-master-set} zawierający
  szablony określające wygląd poszczególnych stron oraz sekwencji
  stron (te ostatnie są opcjonalne, ale typowo są definiowane);
\item zero lub więcej elementów \texttt{fo:declarations};
\item jeden lub więcej elementów \texttt{fo:page-sequance}
 zawierających treść formatowanego dokumentu wraz z~opisem
 jego sformatowania i~podziału na strony.
\end{itemize}

% zakończenie
\summary
Możliwości, jakie stoją przed archiwum prac magisterskich opartych na
XML-u, są ograniczone jedynie czasem, jaki należy poświęcić na pełną
implementację systemu. Nie ma przeszkód technologicznych do stworzenia
co najmniej równie doskonałego repozytorium, jak ma to miejsce w
przypadku ETD. Jeżeli chcemy w pełni uczestniczyć w rozwoju nowej ery
informacji, musimy szczególną uwagę przykładać do odpowiedniej
klasyfikacji i archiwizacji danych. Sądzę, że język XML znacznie to
upraszcza.

% załączniki (opcjonalnie):
\appendix
\chapter{Tytuł załącznika jeden}

Treść załącznika jeden.

\chapter{Tytuł załącznika dwa}

Treść załącznika dwa.

% literatura (obowiązkowo):
\bibliographystyle{unsrt}
\bibliography{xml}

% spis tabel (jeżeli jest potrzebny):
\listoftables

% spis rysunków (jeżeli jest potrzebny):
\listoffigures

\oswiadczenie

\end{document}
